import logging
from ..common.common import SectionHandler
from ..section_handlers.document_acknowlegments import Acknowledgments
from ..section_handlers.document_references import DocumentReferences
from ..section_handlers.document_notes import DocumentNotes
from collections import defaultdict


class Vulnerability(SectionHandler):
    def __init__(self, config):
        super().__init__()
        self.csaf = []
        self.config = config

    def _process_mandatory_elements(self, root_element):
        pass

    @staticmethod
    def _handle_involvements(root_element):
        involvements = []
        for involvement_elem in root_element.Involvement:
            involvement = {'party': involvement_elem.attrib['Party'].lower(),
                           'status': involvement_elem.attrib['Status'].lower().replace(' ', '_')}

            if hasattr(involvement_elem, 'Description'):
                involvement['summary'] = involvement_elem.Description.text
            involvements.append(involvement)

        return involvements

    @staticmethod
    def _handle_product_statuses(root_element):
        statuses = defaultdict(list)
        for status_elem in root_element.Status:
            status_type = status_elem.attrib['Type'].lower().replace(' ', '_')
            product_ids = [product_id.text for product_id in status_elem.ProductID]
            statuses[status_type].extend(product_ids)

        return statuses

    @staticmethod
    def _handle_threats(root_element):
        threats = []
        for threat_elem in root_element.Threat:
            threat = {'details': threat_elem.Description.text,
                      'category': threat_elem.attrib['Type'].lower().replace(' ', '_')}

            if hasattr(threat_elem, 'ProductID'):
                threat['product_ids'] = [product_id.text for product_id in threat_elem.ProductID]

            if hasattr(threat_elem, 'GroupID'):
                threat['group_ids'] = [group_id.text for group_id in threat_elem.GroupID]

            if 'Date' in threat_elem.attrib:
                threat['date'] = threat_elem.attrib['Date']

            threats.append(threat)

        return threats

    @staticmethod
    def _handle_remediations(root_element):

        category_mapping = {'Workaround': 'workaround',
                            'Mitigation': 'mitigation',
                            'Vendor Fix': 'vendor_fix',
                            'None Available': 'none_available',
                            'Will Not Fix': 'no_fix_planned'}

        remediations = []
        for remediation_elem in root_element.Remediation:
            remediation = {'category': category_mapping[remediation_elem.attrib['Type']],
                           'details': remediation_elem.Description.text}

            if hasattr(remediation_elem, 'Entitlement'):
                remediation['entitlements'] = [entitlement.text for entitlement in remediation_elem.Entitlement]

            if hasattr(remediation_elem, 'URL'):
                remediation['url'] = remediation_elem.URL.text

            if hasattr(remediation_elem, 'ProductID'):
                remediation['product_ids'] = [product_id.text for product_id in remediation_elem.ProductID]

            if hasattr(remediation_elem, 'GroupID'):
                remediation['group_ids'] = [group_id.text for group_id in remediation_elem.GroupID]

            if 'Date' in remediation_elem.attrib:
                remediation['date'] = remediation_elem.attrib['Date']

            remediations.append(remediation)

        return remediations

    @staticmethod
    def _parse_score_set(score_set_element, mapping, version, json_property, product_status):

        cvss_score = {'version': version}

        for cvrf, csaf in mapping.items():
            if hasattr(score_set_element, cvrf):
                cvss_score[csaf] = getattr(score_set_element, cvrf).text

        # TODO: How to handle missing products entries?
        product_ids = []
        if hasattr(score_set_element, 'ProductID'):
            product_ids = [product_id.text for product_id in score_set_element.ProductID]
        elif product_status:
            product_ids = []
            if product_status.get('known_affected'):
                product_ids.extend(product_status['known_affected'])
            if product_status.get('first_affected'):
                product_ids.extend(product_status['first_affected'])
            if product_status.get('last_affected'):
                product_ids.extend(product_status['last_affected'])

            product_ids = list(set(product_ids))

        if 'baseScore' not in cvss_score:
            logging.error('No CVSS base score found on the input!')

        if 'vectorString' not in cvss_score:
            logging.error('No CVSS vector string found on the input!')

        if len(product_ids) == 0:
            logging.error('No product_id entry for CVSS score set!')

        score = {json_property: cvss_score,
                 'products': product_ids}

        return score

    @staticmethod
    def _handle_scores(root_element, product_status):
        scores = []

        cvss_v3_mapping = {'BaseScoreV3': 'baseScore',
                           'TemporalScoreV3': 'temporalScore',
                           'EnvironmentalScoreV3': 'environmentalScore',
                           'VectorV3': 'vectorString'}

        cvss_v2_mapping = {'BaseScoreV2': 'baseScore',
                           'TemporalScoreV2': 'temporalScore',
                           'EnvironmentalScoreV2': 'environmentalScore',
                           'VectorV2': 'vectorString'}

        # TODO: VectorV3 is not mandatory on input, but vectorString is mandatory on output
        # TODO: hardcoded cvss version 3.0/3.1 or config param?

        if hasattr(root_element, 'ScoreSetV2'):
            for score_set in root_element.ScoreSetV2:
                score = Vulnerability._parse_score_set(score_set, cvss_v2_mapping, '2.0', 'cvss_v2', product_status)
                scores.append(score)

        if hasattr(root_element, 'ScoreSetV3'):
            for score_set in root_element.ScoreSetV3:
                score = Vulnerability._parse_score_set(score_set, cvss_v3_mapping, '3.0', 'cvss_v3', product_status)
                scores.append(score)

        return scores

    def _process_optional_elements(self, root_element):
        vulnerability = {}

        if hasattr(root_element, 'Acknowledgments'):
            # reuse Acknowledgments handler
            acknowledgments_handler = Acknowledgments()
            acknowledgments_handler.create_csaf(root_element.Acknowledgments)
            vulnerability['acknowledgments'] = acknowledgments_handler.csaf

        if hasattr(root_element, 'CVE'):
            # "^CVE-[0-9]{4}-[0-9]{4,}$" differs from the CVRF regex. Will be checked by json schema validation.
            # TODO: double check, that no regex should be implemented here
            vulnerability['cve'] = root_element.CVE.text

        if hasattr(root_element, 'CWE'):
            CWE_elements = root_element.CWE
            if len(CWE_elements) > 1:
                logging.warning(f'{len(CWE_elements)} CWE elements found, using only the first one.')
            vulnerability['cwe'] = {'id': CWE_elements[0].attrib['ID'],
                                    'name': CWE_elements[0].text}

        if hasattr(root_element, 'DiscoveryDate'):
            vulnerability['discovery_date'] = root_element.DiscoveryDate.text

        if hasattr(root_element, 'ID'):
            vulnerability['id'] = {'system_name': root_element.ID.attrib['SystemName'],
                                   'text': root_element.ID.text}

        if hasattr(root_element, 'Involvements'):
            vulnerability['involvements'] = self._handle_involvements(root_element.Involvements)

        if hasattr(root_element, 'Notes'):
            # reuse DocumentNotes handler
            notes_handler = DocumentNotes()
            notes_handler.create_csaf(root_element.Notes)
            vulnerability['notes'] = notes_handler.csaf

        if hasattr(root_element, 'ProductStatuses'):
            vulnerability['product_status'] = self._handle_product_statuses(root_element.ProductStatuses)

        if hasattr(root_element, 'References'):
            # reuse DocumentReferences handler
            references_handler = DocumentReferences(config=self.config)
            references_handler.create_csaf(root_element.References)
            vulnerability['references'] = references_handler.csaf

        if hasattr(root_element, 'ReleaseDate'):
            vulnerability['release_date'] = root_element.ReleaseDate.text

        if hasattr(root_element, 'Remediations'):
            vulnerability['remediations'] = self._handle_remediations(root_element.Remediations)

        if hasattr(root_element, 'CVSSScoreSets'):
            vulnerability['scores'] = self._handle_scores(root_element.CVSSScoreSets,
                                                          vulnerability.get('product_status'))

        if hasattr(root_element, 'Threats'):
            vulnerability['threats'] = self._handle_threats(root_element.Threats)

        if hasattr(root_element, 'Title'):
            vulnerability['title'] = root_element.Title.text

        self.csaf.append(vulnerability)
